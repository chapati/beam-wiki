The HW wallet should support the following functionality
1. Deterministic key generation for key parameters 
1. Export public keys
1. Participate in signing schemes: Schnorr's signature, Bulletproof.
   * The latter in CPU-hungry, but most of the computations can be done without HW
1. Support multi-signatures
   * This includes both: signing with multiple self keys, as well as the keys generated by the others.
1. Obviously secret keys must not be revealed.

## Nonces and randomness

Our signing protocols follow a ritual where the signer generates some _nonce(s)_, reveals its _image(s)_, gets a _challenge(s)_, and then should reveal the appropriate _preimage_. To guarantee (5) the signer must **never** answer to different _challenges_ for the same _nonce. This is absolutely vital!

In a regular signature protocol the _nonce_ can always be generated in a deterministic way from the visible transcript and the sercret key, the _challenge_ is derived from the visible transcript, and the whole signing process is <u>atomic</u>.

This approach, however, is not compatible with (4). In the case of the multisignature the signing process is not atomic. And ability to create multisignatures is essential in MW.

Hence, in order to sustain the requirements the HW should use another source of (pseudo)randomness. Moreover, the random _nonce_ generated for the signing process should be kept inside the HW for indefinite time, because signing may take considerable time, during which HW wallet should be able to operate normally. In addition each _nonce_ should be erased once the _preimage_ based on it is revealed.

# Proposed design

HW wallet should support the basic EC cryptography primitives for the parameters specified by the `secp256k1` standard (the one that is used in bitcoin). Means - 256-bit wide keys, the same EC equation, finite field parameters, same `G`-generator.

The HW wallet should have non-volatile memory, represented by memory _slots_. There should be the following _slots_.

1. Master secret.
   * No direct access to the caller.
   * Should be used as a secret for key generation.
1. Nonce source.
   * No direct access to the caller.
   * Should be initialized by <u>true random</u> either during production, or upon initialization of the Master secret.
1. Generated key.
   * Contains the generated key. May be a single key or their sum/difference.
1. Generated nonces.

This low-level design may look weird, but it's needed to support all the MW functionality.

The following functionality should be supported:

### Key generation
Parameters:
* `ID` - an opaque 256-bit data that identifies the key
* `i` - the target slot index (number)

Result: the target slot should contain the generated key: `s[i] = KeyGenerate(MasterSecret, ID)`

### Nonce generation
Parameters:
* `i` - the target slot index

Result: the target slot should contain a unique nonce. It should be derived from the Nonce source, and the Nonce source itself should be mutated immediately after that.

* `s[i] = DeriveNonce(NonceSource)`
* `NonceSource = Mutate(NonceSource)`

### Image (public key) reveal
Parameters:
* `i` - the source slot index

Return value: EC point (in whatever representation) equals to the `G`-generator multiplied by the value of this slot: `G * s[i]`

### Simple arithmetics

There should be possible to 