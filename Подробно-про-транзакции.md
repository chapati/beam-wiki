# Основные принципы системы

* В системе нет ингерентного понятия кошелька. Все суммы обозначены через UTXOs, и транзакции по сути являются превращением одних UTXOs в другие.
* UTXO кодируется через Pedersen commitment (т.е. точка на кривой) + rangeproof, который доказывает следующее:
   * Сумма находится в допустимом диапазоне
   * *blinding factor* известен тому кто создал этот UTXO
   * UTXO не был искусственно изменён после того как был создан rangeproof
* Знание открытия UTXO (т.е. сумма + *blinding factor*) - необходимое и достаточное условие для авторизации транзакции с ним. Т.е. по сути это означает владение
   * Это также верно для произвольного набора UTXOs, при этом знание каждого UTXO по отдельности необязательно. 
* По этой причине при транзакции между двумя пользователями суммарные *blinding factor* входов/выходов для обоих пользователей должны отличаться, в протичном случае не происходит "передача собственности". Таким образом любая транзакция обязательно на выходе должна иметь *остаток* (excess).
* Остаток - это разность входных/выходных commitments (т.е. точка на кривой) + сигнатура Шнорра, которая доказывает следующее:
   * Остаток несёт в себе исключительно *blinding factor*, в нём нет суммы.
   * Величина остатка известна тому кто его подписал.
   * Остаток не был искусственно изменён после подписания.

Принципиально то что UTXO и остатки не могут быть созданы без знания их содержания, а также то что они не могут быть впоследствие искусственно изменены.

## Замечание по поводу уникальности UTXO

Что произойдёт если UTXO будут повторяться? Например, пользователь во время транзакций создаст несколько UTXOs с одной суммой и одним *blinding factor* (и в сигнатуре использует один нонс)?

С точки зрения верификации транзакций здесь нет нарушений (надо только аккуратно это имплементировать, учитывая возможные повторения). Но это может привести к сложностям когда пользователь захочет их потратить. 

Представим себе что **A** владеет несколькими идентичными UTXOs, и в какой-то момент авторизует транзакцию в которой переведёт его **B**. Если **B** заметит что таких UTXOs несколько (а это видно из блокчейна), то он может сам авторизовать ещё одну такую же транзакцию!

Чтобы избежать такой ситуации **A** может использовать такой UTXO только в совокупности с другими, уникальными. Т.е. критерий должен быть таким чтобы набор входных UTXOs не имел повторений.

Очевидно что это накладывает ограничения на транзакции, и в нормальной ситуации нет смысла этого делать. Но, как мы увидим позже, у этого могут быть применения.

# Дополнительные возможности

## Аудит UTXO

Смысл в том чтобы владелец UTXO при желании мог раскрыть его сумму, но при этом остаться его владельцем, т.е. не раскрывать *blinding factor*. Это можно сделать достаточно просто таким способом:

Дано: **P** владеет UTXO `C = k*G + v*H` и хочет доказать сумму `v`.
* **P** генерирует нонс `k1` и высчитывает `C1 = k1*G`.
* **P** высчитывает challenge `e = H(C1)`
* **P** высчитывает `k2 = k1 + e*k`

Сигнатура: `(v, C1, k2)`

Проверка сигнатуры: 
* **V** высчитывает challenge `e = H(C1)`
* **V** проверяет `C1 = k2*G - e*(C - v*H)`

Т.е. по сути от `C` отнимается сумма, а далее - обычная сигнатура Шнорра, которая не выдаёт никакой информации о *blinding factor*, следовательно принадлежность UTXO остаётся в силе.

## Вариант *открытого* UTXO

Как вариант можно изначально создать UTXO с открытой суммой и в таком виде использовать его в транзакции, чтобы сумма была известна не только определённому аудитору, а в таком виде вошла в блокчейн и была известна всем.

Можно это имплементировать как обычный UTXO + сигнатура для аудитора, но это неоптимально. Если сумма в любом случае раскрывается, то rangeproof не имеет смысла, и можно представить такой UTXO просто как Pedersen commitment + сигнатура для аудитора. Единственный нюанс: формула для challenge `e` обязательно должна учитывать сумму `v`, чтобы такой UTXO нельзя было модифицировать. Т.е. `e = H(v | C1)`. Иными словами - сигнатура Шнорра в данном случае должна подписывать сумму `v`.

### Как это влияет на механизм транзакций?

Технически - никак. Тот факт что сумма некоторых UTXO известна никак не влияет на верификацию транзакции, т.е. в любом случае проверяется валидность всех входных и выходных UTXOs, остатков, и затем проверяется что разность входов и выходов соответствует сумме остатков.

Но с точки зрения конфиденциальности некоторые последствия есть. Глядя на конкретные транзакции с открытыми UTXO можно оценить суммы по другую сторону (с определённой юристикой), в некоторых ситуациях можно узнать нижнюю/верхнюю границу значений (например если на входе **A** + **B** а на выходе **C**, то понятно что **C > A**).

Но можно предположить что в типичной ситуации, где бОльшая часть транзакций конфиденциальна - эта информации быстро рассеивается. Если учесть запутывание следов через Dandelium, и что в блоке структура и хронология отдельных транзакций стираются, то можно предположить что раскрытие суммы которой владеет конкретный участник маловероятно.

# Какую информацию можно внедрить в транзакцию, и как это можно использовать

До этого момента мы говорили лишь о том что любая транзакция должна иметь остаток (один или несколько), и что остаток по сути представляет из себя точку на кривой + сигнатуру Шнорра. Но, как известно, сигнатура Шнорра может подписать не только сам остаток, но и вообще любое сообщение. А учитывая что от остатков впоследствие нельзя избавиться, это открывает возможности внедрения информации в блокчейн, которая в нём останется навсегда.

Таким образом мы теперь будем говорить не просто про остаток, а про **ядро транзакции** (Transaction kernel), которое помимо остатка позволяет сохранить любую информацию и предотвращает возможность её модификации.

Рассмотрим разные схемы создания транзакций, и то какие это предоставляет возможности.

### Transaction fee

Как мы уже говорили, когда транзакция отправляется в узел, она должна содержать следующее:
* Ссылки на существующие UTXOs
* Новые UTXOs + rangeproof (или другой сигнатурой, в случае если они неконфиденциальные)
* Явный остаток (*offset*)
* Закодированный остаток с сигнатурой
* *Transaction fee*

*Transaction fee* - это прямое отчисление майнеру, сумма которую он присваивает когда закрывает блок. Но, как мы уже говорили, надёжность системы основывается на том что все элементы транзакции (входы, выходы, остатки) должны иметь сигнатуру которая исключает возможность их модификации. То же относится и к *Transaction fee*, поскольку по сути это тоже часть транзакции, точнее - явный выход! Если его никак не защитить, то его можно нелегально присвоить. Например, пользователь посылает транзакцию в узел, нечестный узел присваивает себе часть fee: он просто добавляет в транзакцию новый UTXO, соответственно меняет *offset*, и соответственно уменьшает оставшийся fee. И в таком искажённом виде пересылает это другому узлу.

Чтобы этого избежать <b>*Transaction fee* вписывается непосредственно в *ядро*</b>.

### "Джентельменская" (доверительная) транзакция без условий.

Дано: **S** хочет переслать какую-то сумму **R** без каких-либо условий.
* **S** выбирает принадлежащие ему UTXOs в качестве входа, и генерирует новые UTXOs для сдачи.
* **S** вычисляет суммарные *blinding factor* и сумму (для обоих параметров это входные UTXOs минус выходные).
* **S** связывается с **R** и отправляет ему все эти параметры: входные и выходные UTXOs, *blinding factor* и общую сумму.

На этом миссия **S** заканчивается, **R** сможет закончить транзакцию без него.
* **R** опционально может добавить в транзакцию свои существующие UTXOs.
* **R** самостоятельно решает сколько отчислить за транзакцию (*transaction fee*).
* **R** генерирует новые UTXOs для выхода с общей суммой из которой вычтен fee.
* **R** высчитывает *total blinding factor* транзакци, и случайным образом делит его на явную и неявную части (*offset + excess*).
* **R** генерирует *ядро*, включающий в себя *fee* и подтверждающий неявную часть остатка.
* **R** отправляет транзакцию в узел

Это наиболее простая схема транзакции. **S** раскрывает данные своей части транзакции, далее **R** волен действовать по усмотрению.

### "Жлобская" (недоверительная) транзакция.

Предположим что **S** хочет принять непосредственное участие в подписи *ядра*. Например, он хочет убедиться что будет назначен согласованный *fee*, или желает быть уверенным что в *ядро* будет вписано определённое согласованное сообщение (зачем это надо - увидим позже).

В этом случае схема интеракции следующая:

* **S** и **R** договариваются о сумме транзакции и о сообщении `M` которое должно быть в *ядре* (включает в себя *fee* и пр. данные).
* **S** Оба выбирают UTXOs (входные + выходные), и вычисляют каждый свой суммарный *blinding factor* `xs` и `xr` соответсвенно.
* Оба генерирует нонс `ks` и `kr` соответственно.
* Оба вычисляют и передают друг другу `ks*G`,`xs*G` и `kr*G`,`xr*G` соответственно
* Оба вычисляют `K = kr*G + ks*G` и `X = xr*G + xs*G`.
* Оба вычисляют challenge `e = H(M | X | K)`.
* Оба вычисляют и передают друг другу `ss = ks + e*xs` и `sr = kr + e*xr` соответственно.
* **R** вычисляет `s = ss + sr`.

Сигнатура: `(K,s)`. Полностью *ядро* выглядит так: `(M,X,K,s)`.

Верификация:
* **V** вычисляет challenge `e = H(M | X | K)`.
* **V** проверяет `K = s*G - e*X`.

Легко видеть что данная схема - это по сути мультиподпись Шнорра. *Blinding factor* отдельных частей транзакции выступают в качестве приватных ключей, и в этой схеме участники подписи их не разглашают друг другу, но при этом коллективно подписывают оговоренное сообщение и остаток.

Реалный транскрипт выглядит таким образом:
* **S -> R**
    * Вдохные/выходные UTXOs
    * сумма, `M`
    * `ks*G`, `xs*G`
* **R -> S**
    * `kr*G`, `xr*G`
* **S -> R**
    * `ss`
* **R -> Узел**
    * Вдохные/выходные UTXOs
    * *ядро транзакции* (гарантированно включающее сообщение `M`)
    * *offset*

Данная схема требует 1 дополнительный цикл интеракции между **S** и **R**, что логично для мультиподписи.

## Отсроченные транзакции (Timelocked transactions)

Одно из возможных применений сообщений внутри *ядра транзакции* - это создание отсроченных транзакций. Сообщение включает в себя параметр `block_height`, который обозначает минимальную длину блокчейна в котором выходы транзакции могут быть использованы.
Блок по определению системы не может содержать *ядро* в котором `block_height` больше высоты текущего блока, такой блок не проходит валидацию.

Таким образом участники могут создать отсроченную транзакцию. Эта идея имплементирована в грине.

### Открытый вопрос

Могут ли участники тратить свои входные UTXOs до того как их отсроченная транзакция может быть применена (т.е. таким образом её запороть)? Можно ли / нужно ли предотвращать такой сценарий?
Поскольку такая транзакция не может войти в блок, она по сути не является частью консенсуса, и это позволяет трату входных UTXOs.

Возможное решение: структура блока меняется таким образом чтобы позволить хранение отсроченных транзакций.

Как известно, блок представляет из себя по сути одну большую транзакцию: много ссылок на входные UTXOs, много выходных UTXOs, много *ядер*, и 1 *offset*.

Меняем блок таким образом чтобы он состоял из одной большой транзакции где все выходы ликвидны, а также из списка отсроченных транзакций.

Валидация блока включает следующее:
* Проверяется валидность ликвидной транзакции.
* Проверяется валидность всех неликвидных транзакций, а также то что они действительно к этому моменту неликвидны (т.е. имеют слишком высокий `block_height`).
* Неликвидные транзакции должны содержать ровно 1 *ядро*, это подтверждает что они не объединялись, т.е. мы не разрешаем отсроченные выходы использовать в других отсроченных транзакциях.
* Проверяется что нет нелегальных трат, т.е. UTXO не тратится одновременно в разных транзакциях, и что нигде на входе нет неликвидного UTXO.

## Сложные варианты транзакций

Используя мультиподпись, отсроченные транзакции и возможность аггрегации rangeproof можно создавать следующие транзакции:

### Общий UTXO (Multiparty outputs)
UTXO который может быть потрачен лишь коллективно, так что участники по отдельности не знают его *blinding factor*.

### Multiparty Timelocks
Эта схема представляет из себя гибрид из транзакции создающей общий UTXO, и отсроченной обратной транзакции. 

Идея в том что **A** создаёт UTXO который является общим для **A** и **B**, и одновремнно с этим создаётся отсроченная транзакция которая вернёт это назад **A**. Таким образом **A** доказывает что обладает средствами, блокирует их, и пытается сотрудничать с **B**. В случае если не договорятся - средства гарантированно вернутся **A**.

### Транзакция передающая приватный ключ (позиционируется как Atomic Swap).

**A** хочет перевести средства **B** в обмен на приватный ключ (публичный ключ известен). Интеракция устроена таким образом что окончательную сигнатуру на *ядро* создаёт **B**. В процессе интеракции **A** убеждается что **B** знает ключ, и сигнатура строится таким образом, чтобы **A** и только **A** мог из неё вычислить private key.

Таким образом **A** помогает авторизовать транзакцию которая переведёт средства **B**, а когда эта транзакция зайдёт в блокчейн - он сможет найти нужное *ядро* и из его сигнатуры (и своих сохранённых данных) вычислить ключ.

## Прочие применения сообщения сообщения в *ядре*

Помимо прочего можно позволить хранить в этом сообщении произвольную информацию. С точки зрения системы она не имеет смысла, но может использоваться пользователями в качестве доказательства контракта.
Надо лишь ограничить максимальный размер этого сообщения (чтобы нельзя было засорять систему). А применять это можно, к примеру, как хэш какого-то контракта, который пользователи при желании могут огласить.

# Односторонние переводы

Мы хотим предоставить возможность совершать односторонние переводы. Т.е. чтобы **A** мог перевести средства **B** без участия последнего. Эта задача нетривиальна по той причине, что транзакции в MimbleWimble предполагают участие всех сторон, т.е. должна быть интеракция.

Для простоты предположим что **B** ожидает получить от **A** определённую известную сумму, и он даже приготовил UTXO который тот должен ему подарить. Вопрос, разумеется, с *blinding factor*. Если **A** его знает, то он легко может построить такую транзакцию, но в этом случае, как мы знаем, **A** по сути останется его владельцем, и в любой момент сможет сам анонимно его потратить.

Наша схема такова. **B** ожидает получить определённую сумму, он создал UTXO с этой суммой, *blinding factor* не разглашается. Вместо этого он создаёт *ядро транзакции* который соответствует данному UTXO, т.е. компенсирует остаток. UTXO + *ядро* известны для того кто хочет сделать перевод.

### Наивная схема перевода

**A** хочет сделать перевод. Он выбирает свои входные/выходные UTXOs, и создаёт *ядро* которое учитывает лишь его часть транзакции. Затем он добавляет в качестве выхода UTXO принадлежащий **B**, и соответственно добавляет в транзакцию его *ядро*.

Таким образом получаем транзакцию с двумя *ядрами* (что легитимно), которая проходит валидацию.

### В чём подвох?

Надо помнить о том что знание *blinding factor* фактически означает контроль. Наша транзакция на самом деле состоит из двух частей, **A** и **B**, причём для каждой части *total blinding factor* (UTXOs + *ядро*) равен нулю. В то время как сумма не равна нулю, часть **A** является донором, **B** - акцептором.

Предположим что такая транзакция отправляется в нечестный узел. Он понимает какую транзакцию получил (либо перебором заметил что транзакция распадается на 2 части, либо заранее знает, ведь то что **B** ожидает перевод - не секрет).
В этом случае узел просто выбрасывает ту часть которая является акцпетором, и вместо этого становится акцептором сам! Т.е. создаёт свой UTXO и своё *ядро*, и в таком виде отправляет это майнеру.

### Что можно сделать?

Решение может быть таким: надо допустить **ядерный синтез**. Донор должен создать *ядро* таким образом, чтобы впоследствие из транзакции (и затем из блокчейна) невозможно было выкинуть *ядро* нужного акцептора. *Ядро* донора должно в явном виде ссылаться на *ядро* акцептора, и валидация транзакции/блока должна это проверить: если одно *ядро* ссылается на другое, то оно должен также присутствовать (технически их просто можно записывать непосредственно друг за другом).

### Можно ли делать множественные односторонние переводы?

Строго говоря - можно, но надо помнить что подаренные UTXOs становятся неуникальными, и их трата должна проводиться аккуратно (с привлечением других уникальных UTXOs).

### Можно ли переводить произвольные суммы?

Выглядит сложно. Создать UTXO в том виде в котором он определён сейчас, не зная его *blinding factor* - невозможно (даже если его сумма открыта, всё равно она должна быть подписана со знанием *blinding factor*).

Скорее всего нет смысла, даже если и возможно. Акцептор может создать несколько вариантов UTXOs для разных сумм, комбинируя их можно с нужной точностью получить то что надо.

# Treasury (отчисления разработчикам)

По правилам майнер должен перевести часть заработанных средств разработчикам. И мы не хотим чтобы для закрытия блока обязательно надо было связываться с разработчиками, т.к. такую систему слишком легко парализовать.

Эту задачу можно решить при помощи схемы односторонних переводов. Нужный UTXO + *ядро* акцептора (т.е. разработчиков) можно записать в генезис-блок.
Поскольку treasury рассчитан на определённый срок (4 года) и должно быть конечное кол-во отчислений, можно избежать неудобства неуникальных UTXOs. Вместо этого можно вписать нужное кол-во уникальных UTXOs + *ядер* в генезис-блок, и майнер, всякий раз закрывая блок, должен будет дарить соответствующий UTXO.

Валидация блока должна проверить присутствие в блоке соответствующих *ядер* связанных с treasury, это доказывает факт переводов.


