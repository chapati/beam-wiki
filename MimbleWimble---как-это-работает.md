# Какая идея за этим стоит

В биткоине есть понятие кошелька (wallet), и по сути весь blockchain является описанием транзакций между кошельками (плюс явные эмиссии новых монет). Фундаментальный недостаток такой системы - отсутствие секретности. Информация о всех сделках данного кошелька является достоянием общественности. В тот момент когда кошельки совершают транзакцию - они должны разгласить друг другу свой public key, и с этого момента они видят всю историю друг друга как прошлых так и будущих транзакций.

В MimbleWimble понятие кошелька отсутствует. Вместо этого существуют конкретные непотраченные суммы (UTXO - unspent transaction output), которые принадлежат конкретным лицам. И транзакции совершаются на уровне UTXOs, а не между кошельками. Т.е. транзакция - это превращение одних UTXOs в другие.

UTXO кодируется при помощи Pedersen commitments + range proof, так что существование UTXO является достоянием общественности, но лишь владелец знает его открытие, т.е. сумму и *blinding factor*.

Транзакции должны работать таким образом чтобы:
* Конкретные суммы не должны быть известны никому кроме участников транзакции, но при этом можно проверить что переданная сумма равно полученной, т.е. что не происходит illegal inflation.
* Владелец UTXO авторизовал транзакцию, т.е. без его участия невозможно использовать его UTXO.

### Наивная схема:

Рассмотрим простой пример: **A** владеет `C1 = k1*G + v1*H` и `C2 = k2*G + v2*H`, и он хочет передать это **B**.

* **A** сообщает **B** (по секретному каналу) что он хочет ему передать `C1,C2`, и разглашает их содержимое.
* **B** создаёт транзакцию в которой на входе потребляются `C1,C2`, а на выходе получается `C3 = (k1+k2)*G + (v1+v2)*H`
* В узел отправляется транзакция `C1,C2` -> `C3` + range proof для `C3`.
* Узел проверяет что `C1 + C2 = C3`, и что `C3` имеет правильный range proof, при этом суммы и личности не расрываются

### Почему это недостаточно хорошо?

Такая транзакция симметрична, и, следовательно, **обратима**. И **A** и **B** оба знают сумму и *blinding factor*. Поэтому результат транзакции по сути всё ещё принадлежит **A**. Ничто не помешает ему авторизовать транзакцию которая использует `C3`.

Чтобы это решить необходимо фундаметальное ограничение: транзакции должны быть **необратимы**. Для этого надо чтобы **A** не знал раскрытие `C3`. А это значит что сумма входов и выходов транзакции должна быть ненулевая, должен быть остаток (excess).

### Улучшенная схема.

**A** владеет `C1 = k1*G + v1*H` и `C2 = k2*G + v2*H`, и он хочет передать это **B**.

* **A** сообщает **B** (по секретному каналу) что он хочет ему передать `C1,C2`, и разглашает их содержимое.
* **B** создаёт `C3 = k3*G + (v1+v2)*H`, где `k3` - случайно выбранный новый *blinding factor*
* **B** высчитывает `k = k1+k2 - k3` - *total blinding factor*
* **B** высчитывает `X = k*G` - остаток (excess), и создаёт для него подпись Шнорра
* В узел отправляется транзакция `C1,C2` -> `C3` + range proof для `C3`, `X` + сигнатура.
* Узел проверяет что `C1 + C2 - C3 = X`, что `C3` имеет правильный range proof, и что `X` имеет правильную сигнатуру, которая подтверждает что точка `X` не содержит в себе суммы.

Важно что остаток (excess) может быть только на выходе транзакции, но не на входе. Это то что делает её асимметричной и необратимой.

### Вариант со сдачей.

Предположим что **A** хочет потратить `C1,C2` не целиком, т.е. он хочет чтобы на выходе транзакции появился дополнительный UTXO с полагающейся ему сдачей, при этом чтобы владельцем этого UTXO был именно он.

Для этого нужно небольшое изменени схемы: **A** не должен посылать **B** полное раскрытие своих UTXOs (т.к. в этом случае **B** сможет забрать всё). Вместо этого он должен послать входные UTXOs, выходные UTXOs, а также общую сумму транзакции и общий *blinding factor*. Т.е. раскрыть надо не все UTXOs по отдельности, а общий commitment состоящий из входных и выходных UTXOs.

Это подводит нас к выводу о том что владеть (т.е. использовать в транзакциях) можно не только отдельными UTXOs, но и определёнными их наборами (при этом не имея возможности использовать их по отдельности).

### Почему эта схема надёжная?

Транзакция состоит из 3 частей:
1. входные и выходные UTXOs которые принадлежат тому кто авторизует транзакцию (т.е. получатель).
2. входные и выходные UTXOs которые принадлежат другим лицам которые дали согласие на транзакцию (отправители)
3. остаток

В нормальной ситуации получатель знает *blinding factor* для всех трёх частей: т.е. он естественно знает *blinding factor* своих UTXOs, знает суммарный *blinding factor* для того что он получил от отправителя и, соответственно, может посчитать *blinding factor* остатка.

Если же он попытется создать транзакцию используя наборы UTXOs которые ему не принадлежат, то в этом случае он не будет знать (2).
Для (3) он обязан знать *blinding factor*, т.к. в противном случае невозможно высчитать правильную сигнатуру остатка.

Получается что он вынужден создать (1) для которых *blinding factor* неизвестен для него самого. Т.е. он должен украсть чужие UTXOs и превратить их в свои, таким образом что он и сам не будет знать их *blinding factor*.
Если бы UTXO содержал только лишь commitment, то это могло бы сработать, но в реальности UTXO содержит ещё и range proof, а чтобы его создать надо знать раскрытие commitment. Так что это тоже не сработает.

Таким образом гарантируется что можно использовать лишь наборы UTXOs с известными *blinding factor* и суммой.

### Объединение транзакций

Механизм транзакций позволяет легко их объединять, нужно лишь допустить что одна транзакция может содержать несколько остатков. Причём если выходные UTXOs одной транзакции являются входными для другой - то их можно полностью удалить, т.е. при объединении транзакций не должно быть одинаковых UTXOs по разные стороны.

Заметим что остатки объединить невозможно (по крайней мере если используется сигнатура Шнорра).

При формировании блока все транзакции объединяются и по сути весь блок - это одна большшая транзакция. Более того, блоки также можно объединять. Подробнее об этом позже.

### Дополнительные детали

Схема транзакции с лёгкостью может быть расширена чтобы включить transaction fee - плата за транзакцию, сумма указанная в явном виде, которая идёт майнеру. В этом случае верификация соответственно должна учесть что от суммы входов/выходов надо ещё вычесть `fee*H` для верификации.

По идее можно к остаткам "прицепить" произвольные сообщения, которые должны будут остаться в блокчейне навсегда. Это делается просто: сигнатура Шнорра для остатка будет подписывать не пустое сообщение, а какое-то определённое, которое будет включено в транзакцию вместе с остатком. Точно не знаю для чего это может быть использовано, но, возможно, этому можно найти применение. Например, какой-то контракт, который впоследствие можно раскрыть.

## Дополнительное запутывание следов.

Сам по себе протокол гарантирует конфиденциальнсть транзакций. Но определённая информация всё-таки может быть получена.

1. Привязка по IP. Получая транзакцию от пользователя узел может привязать UTXOs к IP адресу.
2. История транзакций. Если предположить что транзакции последовательно записываются в блок, то можно увидеть их порядок.
3. После объединения транзакция в блоке можно путём перебора понять какие комбинации входов/выходов подходят к существующим остаткам и, таким образом, догадаться какими были транзакции.

Для решения этих проблем используются следующие прёмы:

1. Dandelion - идея в том чтобы транзакцию в узел отсылал не непосредственный участник транзакции а случайный пользователь. Для этого готовая транзакция отсылается не в узел, а случайному пользователю, со случайно сгенерированным TTL (счётчик time-to-live). Он в свою очередь также должен отослать это случайному пользователю, при этом уменьшив TTL. В тот момент когда TTL=0 транзакция отсылается в узел.

2. Для запутывания истории транзакций по конвенции все входы/выходы сортируются. Это во-первых стирает их хронологический порядок, во-вторых упрощает их объединение (т.е. если UTXO присутстсвует с обеих сторон и должен быть удалён - это легче заметить).

3. Проблему подгона UTXOs под существующие остатки можно решить таким способом: определить что остатки состоят из двух составляющих:
* Закодированная часть (commitment + сигнатура), как и прежде
* Offset - явная часть, т.е. скаляр в явном виде.

При формировании транзакции тот кто её авторизует вычисляет остаток, и случайным образом его делит на закодированную и явную части. Идея в том что про объединении транзакций offsets складываются. Т.е. транзакция (а также целый блок) включает в себя много остатков, и ещё 1 offset. Причём уже невозможно подогнать UTXOs под существующие остатки.




# Терминология

* UTXO - unspent transaction output
  * Определяется как Pedersen commitment + соответствующий range proof
  * Владение (ownership) - означает возможность использовать в транзакциях. Требует знания раскрытия (`k,v`), как мы в последствие увидим
  * k - называется *blinding factor*, по сути является private key.
* Excess - commitment для которого `v=0`. Т.е. вида `C=k*G`
* Excess signature - док-во знания раскрытия, сигнатура Шнорра.
  * можно использовать подпись Шнорра, где сообщение пустое
* Transaction fee - явно заданная сумма которая добавляется/убирается из транзакции, в соответствии с правилами
* Transaction kernel - Excess + Signature, Transaction Fee
* Transaction offset - явно заданный дополнительный *blinding factor*

Транзакция состоит из следующего:
* список ссылок на существующие (к данному моменту) UTXOs
* список новых UTXOs которые должны получиться после транзакции
* список Transaction kernels (минимум 1, может быть больше)
