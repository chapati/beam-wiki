Подробно [здесь](https://ru.wikipedia.org/wiki/%D0%AD%D0%BB%D0%BB%D0%B8%D0%BF%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F).

Неплохое наглядное объяснение (на английском) [здесь](https://www.youtube.com/watch?v=F3zzNa42-tQ)
Необходимо задать следующие параметры:
* Простое число `p` определяющее конечное поле `Zp`.
* Параметры кривой (коэффициенты `a`,`b`)
	
Эти параметры выбираются изначально, и не являются секретными.

Величина простого числа `p` по сути определяет размерность (битность) задачи. Число `p` подбирается близко к максимальному для выбранного размера (кол-ва битов) для того чтобы во-первых максимально использовать весь диапазон чисел, во-вторых для того чтобы случайно выбранное число с высокой вероятностью было в допустимом диапазоне.

В Bitcoin и MimbleWimble используются следующие параметры: 
* Размерность задачи: 256 бит (32 байта)
* Простое число: 2<sup>256</sup> - 2<sup>32</sup> - 2<sup>9</sup> - 2<sup>8</sup> - 2<sup>7</sup> - 2<sup>6</sup> - 2<sup>4</sup> - 1 = FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE FFFFFC2F
* Уравнение кривой: y<sup>2</sup> = x<sup>3</sup> + 7

Есть 2 типа объектов:
* Скаляр: 256-битное число в допустимом диапазоне, т.е. от 0 до `p` (не включительно)
* Точка на кривой: Пара координат (256-битных чисел), которые удовлетворяют уравнению кривой.
		
Формально точки обозначаются заглавными буквами, а скаляры - строчными (`k` - scalar, `C` - point).
Точки представляют собой группу по сложению. Т.е. точки можно складывать и вычитать. Умножение точки на скаляр определено как сложение точки с собой соответствующее кол-во раз.
		
# Как это используется для криптографии?

Криптография основана на сложности вычисления дискретного логарифма (Elliptic Curve Discrete Logarithm Problem). Если дано `G`, и `C = k*G`, то нет эфективного (субэкспоненциального) алгоритма который может найти `k`.

Примечание: строго говоря в данном контексте это не логарифм а "деление", но это из-за формального определения операции как "сложение". В другой нотации вместо сложения это обозначается умножением, а умножение на скаляр - возведение в степень. Отсюда и название логарифма. В любом случае это является частным случаем общей проблемы "order finding".

Таким образом умножение точки на скаляр - это **односторонняя** функция (one-way function), при этом **гомоморфная**, т.е.

`k1*G + k2*G = (k1 + k2)*G`.

Для применения в криптографии выбирается точка `G`, и она общеизвестна (так же как и параметры кривой). Эта точка называется генератор.

Скаляр называют secret key (sk), а его произведение на генератор - public key (pk).

# Примеры использования

## Diffie-Hellman.

**A**,**B** хотят получить "shared secret".
	
*  **A** генерирует случайный `ka`, и посылает `ka*G`
*  **B** генерирует случайный `kb`, и посылает `kb*G`
*  Оба высчитывают `ka*kb*G`. Т.е. каждый домножает свой sk на полученный pk. Полученная точка - это "shared secret"

## Доказательство знания ключа.

Дано `C = k*G`, **A** хочет доказать что он знает `k`, при этом не разглашая его.
	
*  **A** генерирует случайный нонс `k1` и посылает `C1 = k1*G`
*  **B** генерирует случайный challenge (вызов) `e`
*  **A** высчитывает и посылает `k2 = k1 + e*k`
*  **B** проверяет что `k2*G = C1 + e*C`
	
Примечания:
*  Порядок передачи информации (транскрипт) важен. Если бы `e` был известен до посылки `C1`, то легко видеть что схема взламывается, т.е. можно выдержать протокол ничего не зная про `k`.
   *  Это доказывает zero-knowledge, т.е. то что данный транскрипт не разглашает никакой информации о `k`.
*  нонс `k1` должен выбираться случайным образом для каждого док-ва, нельзя использовать один `k1` для разных вызовов, т.к. зная `k1 + e*k` для разных значений `e` можно легко вычислить `k`.
   *  Это доказывает soundness, т.е. то что доказывающий знает `k`.
*  В качестве оптимизации вместо `C1` можно разгласить лишь координату `x` этой точки (т.е. `C1.x`). В таком случае B проверяет верность выражения: `C1.x = (e*C - k2*G).x`

## [ECDSA: Elliptic Curve Digital Signature Algorithm](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)

# Неинтерактивные схемы

Обычно криптографические док-ва предполагают интеракцию между **P**rover и **V**erifier. Что-то вроде **P** разглашает какие-то данные, **V** посылает challenge, **P** высчитывает и посылает ответ, **V** подтверждает ответ. В зависимости от схемы может быть много циклов запросов-ответов, причём порядок передачи информации (transcript) имеет решающее значение.
	
Существует возможность превратить такие криптографические док-ва в неинтерактивные, используя т.н. "random oracle model". Идея в том чтобы в процессе док-ва запрос поступал не от реального **V**, а мог быть получен детерминистическим способом. При этом должно соблюдаться следующее:
* Запрос должен быть посчитан на основе всех данных которые **P** разгласил к настоящему моменту.
* Алгоритм должен быть "непрозрачным", т.е. исключать практическую возможность подгона.

Практически для этого используется хэш-функции (в Bitcoin/MW используется SHA256), вводом для неё служит полный транскрипт к текущему моменту.
	
Получается что с одной стороны у **P** есть преимущество: он знает какой будет вызов прежде чем он **разгласил** свои данные. Но с другой стороны нет практической возможности подгона: если он меняет данные, то это влечёт за собой изменение вызова таким образом что практической возможности подогнать вызов под данные у него нет.
	
Преимущество неинтерактивных схем в том что их можно использовать в структурах данных криптографических систем, так что любой желающий может их верифицировать в оффлайн-режиме, без участия **P**.

# Подпись Шнорра (Schnorr's signature)

Подпись Шнорра является (в определённом смысле) альтернативой ECDSA, и по сути является обобщением док-ва знания приватного ключа `k` (пример который мы уже рассмотрели) с использованием неинтерактивной схемы, которая завязана также на сообщении которое необходимо подписать.
	
Дано: **A** хочет подписать сообщение `M` используя приватный ключ `k`, причём публичный ключ `C = k*G` общеизвестен.
	
* **A** генерирует случайный нонс `k1` и вычисляет `C1 = k1*G`
* **A** высчитывает challenge по формуле `e = H(C1 | M)`
* **A** высчитывает `k2 = k1 + e*k`
	
Сигнатура: `(C1, k2)`

**B** проверяет сигнатуру:
* **B** высчитывает challenge по формуле `e = H(C1 | M)`
* **B** проверяет: `C1 = k2*G - e*C`

Примечания:
* В основе этой схемы лежит неинтерактивная схема, при которой обе стороны могут независимо вычислить вызов `e`
* Формула обязательно учитывает и подписываемое сообщение, и часть сигнатуры `C1`.
* Размер сигнатуры можно скомпрессировать. Например, вместо точки `C1` она может содержать лишь её координату `x`, или её хэш-функцию (т.е. `H(C1)`). При этом, разумеется, формула для вычисления вызова `e` должна быть соответственно изменена, и использовать лишь то что есть в сигнатуре.

## Мультиподпись (multisignature)

Одно из преимуществ подписи Шнорра в том что её легко можно обобшить на случай при котором `N` участников хотят коллективно подписать сообщение `M`, причём размер подписи не зависит от кол-ва участников. Это возможно благодаря тому что подпись по сути представляет из себя скаляр и точку на кривой, причём оба образуют группу по сложению. Т.е. мультиподпись является по сути суммой подписей.
Нюанс заключается лишь в том чтобы все участники подписи и, впоследствие, проверяющий (verifier) использовали один вызов `e`.

Дано: `N` участников, обозначены как **P[i]**, хотят подписать сообщение `M` используя приватные ключи `k[i]`, причём публичные ключи `C[i] = k[i]*G` общеизвестны.

* Каждый из участников **P[i]** генерирует случайный нонс `k1[i]`, и вычисляет `C1[i] = k1*G`
* Участники суммируют полученные `C1[i]`. Результат обозначаем `C1`
* Каждый из участников высчитывает challenge по формуле `e = H(C1 | M)`
* Каждый из участников высчитывает `k2[i] = k1[i] + e*k[i]`
* Участники суммируют полученные `k2[i]`. Результат обозначаем `k2`

Сигнатура: `(C1, k2)`

**V** проверяет сигнатуру:
* **V** высчитывает challenge по формуле `e = H(C1 | M)`
* **V** суммирует все публичные ключи `C[i]`. Результат обозначаем `C`.
* **V** проверяет: `C1 = k2*G - e*C`

Примечания:
* Легко видеть что эта схема является обобщением случая с одним подписывающим.
* Как и для одного подписывающего, сигнатуру можно сократить если использовать `C1.x` или `H(C1)`.
* Каждый из подписывающих видит что именно он подписывает (сообщение `M`), и его часть подписи невозможно использовать для чего-то другого (т.е. украсть подпись)
* Подписывающие могут не знать с кем вместе они подписывают сообщение, в определённом смысле это им даёт некую анонимность. Если же надо чтобы подпись участника являлась подтверждением того что он знает состав подписывающих - надо изменить формулу для challenge `e` так чтобы она в явном виде использовала все публичные ключи участников.


# Pedersen commitments (обязательства)

Предположим что у нас есть значение `v` которое мы хотим закодировать. Строго говоря `v` может быть любым, но это не случайно выбранное значение (рандом), а некий параметр, который атакующий может попробовать угадать, и на практике это может быть относительно небольшое число (по сравнению с 256-бит).
	
Поэтому если мы его закодируем по стандартной схеме `v*G`, то это можно легко сломать, т.е. угадать/подобрать нужный `v`.
	
Чтобы решить это мы расширяем нашу задачу. До этого момента мы работали с 1 генератором `G`. Теперь мы добавляем дополнительный генератор: точку `H`, которая является общеизвестной. Значение кодируется через выражение: `C = kG + vH`.
* `k` - это приватный ключ (также как и прежде)
* `v` - это значение которое мы кодируем
		
Это называется "обязательство" (commitment). Оно обладает следующими свойствами:
* Hiding: из этого выражения невозможно получить никакой информации про `v`.
* Binding: Если кто-то сгенерировал `C`, то он не сможет получить тот же `C` используя другие `k,v`. Если впоследствие надо будет раскрыть (reveal) его содержимое, то придётся разгласить именно эти `k,v`.
		
Примечание:
* Важно чтобы никто не знал соотношение между `G` и `H`, т.е. чтобы никто не знал `x` так что `H = x*G`. В противном случае теряется Binding, т.к. можно будет менять `k,v`  сохраняя при этом commitment.
* По этой причине мы не можем просто заявить что токи `G,H` выбраны нами рандомально, могут заподозрить что мы взяли `H = x*G`, где `x` - известен только нам.
* Мы должны раскрыть схему по которой точки `G,H` были выбраны. Например, можно взять разные строчки, и пропустив их через хэш-функцию получить точки `G,H`.

## Док-во знания раскрытия

Дано commitment `C = k*G + v*H`, **A** хочет доказать что он знает его содержимое, не разглашая при этом деталей.

* **A** генерирует рандомальные `k1,v1`
* **A** Вычисляет и разглашает `C1 = k1*G + v1*H`
* **B** посылает challenge `e`
* **A** вычисляет и посылает `k2 = k1 + e*k`, `v2 = v1 + e*v`.
* **B** проверяет: `k2*G + v2*H = C1 + e*C`

Примечания:
* Легко видеть что схема в которой присутствуют 2 генератора и 2 параметра также является гомоморфной, т.е. `C(k1+k2,v1+v2) = C(k1,v1) + C(k2,v2)`.
* Транскрипт док-ва является обощением док-ва для одного параметра, и его также можно превратить в неинтерактивную схему, и для более компактной формы достаточно использовать `C1.x` вместо `C1`.

## Range proofs

При помощи Pedersen commitment можно эфективно кодировать значения `v`. Но важно помнить про следующие нюансы:

* Их можно "менять" не зная содержимое. Т.е. зная `C(k,v)` можно легко создать `C(k+dk,v+dv) = C(k,v) + C(dk,dv)`
* Значение `v` может быть любым в диапазоне [0 - `p`].

В MimbleWimble, как мы в последствие увидим,  `v` интерпретируется как сумма, и во время транзакций commitments складываются/вычитаются, соответственно складываются/вычитаются заявленные суммы. Поэтому важно чтобы значение `v` было ограничено, и чтобы в процессе арифметических действий не возникал overflow. По сути значения `v` близкие к `p` эквивалентны отрицательным значениям, чего допускать нельзя.

Существуют схемы доказательства того что `v` находится в определённом диапазоне, при этом не разглашающие никакой информации кроме непосредственно этого утверждения.

Pedersen commitment в совокупности с Range proof позволяют проверить следующее:
* Доказательство того что `v` находится в определённом диапазоне значений.
* Доказательство того что создатель range proof знает раскрытие commitment, и что его с тех пор никто не менял.

В MimbleWimble используется Range Proof который доказывает что значение `v` находится в диапазоне [1, 2<sup>64</sup>]. Это практически даёт достаточно большой диапазон значений для одного commitment, при этом остаётся большой запас на их кол-во которое можно безопасно суммировать.
