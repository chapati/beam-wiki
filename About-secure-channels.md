## About secure channels

### Общие положения

1. BBS броадкастит шифрованные сообщения слушателям, плюс хранит историю сообщений глубиной T секунд и имеет возможность по запросу отправлять куски истории подписчику

2. Поднимается N BBS узлов равномерно по глобусу, которые образуют соответственно N каналов. Выполняется M-кратное резервирование (т.е. сообщение отправляется в M<=N узлов, вероятность того, что отправителю и получателю не будет доступно все M узлов одновременно, минимальна)

3. У получателя сообщения есть какой-либо ID в системе (любая строка ограниченной длины), по которому через Address book (децентрализованный сервис) можно получить публичный ключ для шифрования заголовков сообщения. ID должен быть уникальный. Если у ID ограниченный срок действия, то Expiration Timestamp должен являться частью ID, например имена вида VassilePoupkine_1567890123, HGJKE9843_1567890123 будут валидны только до секунды 1567890123

4. Сообщение состоит из заголовка { hash(Address_BBS_канала, ID_получателя), AES_ключ, AES_IV }, зашифрованного публичным ключом получателя и собственно сообщения протокола, зашифрованного с помощью AES ключа и IV. Последние генерируются как случайные числа (из источника с высокой энтропией). Поле Address_BBS_канала присутствует в заголовке для того, чтобы при отправке сообщения в M каналов они были разные. Иначе мониторя трафик BBS узлов можно будет идентифицировать получателя (когда абонентов относительно мало, комбинации M из N в соответствии их парам { ID, public_Key } возможно проиндексировать и радикально сузить круг подозреваемых)

5. На стороне получателя принимаются все сообщения из M каналов, для каждого приватным ключом делается попытка расшифровать заголовок, если успешно, значит сообщение предназначено данному получателю, далее дубликаты отфильтровываются, и то что осталось расшифровывается ключом AES из заголовка и идет в обработку

### Адресация и резервирование

1. Пусть H = hash(ID | public_Key); U = uint64(H) - первые 8 байтов от H; P = U % X - номер комбинации из M каналов, которые может слушать получатель, Х - число возможных комбинаций каналов

2. X = C(M, N) = N! / ( (N-M)! * M!) - число сочетаний т.е. Например, в системе из 20 каналов с тройным резервированием X(3, 20) = 20 * 19 * 18/(1 * 2 * 3) = 1140

3. Числа M и N это компромисс между противоречащими факторами: возможностями сети (N и возможности их координации ограничены), безопасностью (большое M - меньшее секьюрити) и надежностью (M = 1 это плохо) и нагрузкой на приемник. Вобщем М это где-то 3 или 4, 5 уже под вопросом, а N - до нескольких десятков

4. Комбинация из номеров каналов генерируется из { P, M, N } (линейно, см. std::next_permutation() - UPD: долго это, надо в задачки по алгоритмам посмотреть, как быстро и нерекурсивно сделать, оно есть жи). Адреса действующих BBS по номерам каналов надо чтоб возвращались нодами самого блокчейна, которые как раз и образуют координирующую P2P сеть с возможностями броадкаста, анонсов и т.д.

5. Вобщем если одновременно будет недоступно M BBS узлов, будет соотв. недоступно 1/Х секьюрных каналов

### BBS

1. Такое предложение: узлы BBS поднимаются отдельно, их кол-во должно равняться числу каналов N. А вопросы BBS address discovery координируются нодами Beam

2. Ноды beam умеют возвращать список BBS адресов поканально. А формируется он так: узел BBS поднимается и лезет в сеть Node посмотреть этот список. Потом он себя анонсирует как слушатель n-го канала, который не представлен в списке, и эта информация броадкастится по сети. Могут и отказать, если кто-то успел раньше.

3. С каким-то разумным периодом BBS узел заявляет в сеть Beam, что он еще жив. Это так семейство кошачьих метит свои участки. Если кто-то умер, то по прошествии времени участок может быть занят.

4. Issues: авторизация BBS узлов во избежание ползучих атак, M, N. Делегирование легким или ограниченным клиентом предварительной фильтрации на стороне сервера - тогда надо 2 пары ключей и 2-й заголовок, например hash(Address_BBS_канала, ID_получателя)

### Address book

1. Это всего лишь альтернативный способ получить public_Key по ID. Вполне возможно, кто-то захочет разместить это публично, обладая публичным ID. Обязательно должна быть возможность скопипастить в GUI парочку { ID, public_Key} откуда либо из мессенджера или почты, а также из файла

2. Поднимается любое количество узлов AddressBook, они между собой образуют свою P2P/DHT сеть и все это делается на базе openDHT библиотеки (там много лишнего для данной задачи, но этот код годами объезжен и отлажен)

3. Узлы AddressBook также анонсируют себя в сети Beam, принцип тот же, что и у нод BBS, но без каналов и ограничений. В ответ на запрос об адресах AddressBook DHT нода может выдать несколько (тут эксперимент нужен сколько оптимально) рандомных адресов из списка действующих, клиенту достаточно зацепиться хотя бы за 1.

4. Если ID имеет вид *_Timestamp, то информация валидна до заданного времени. Имя вместе со временем на первый взгляд неудобно, но обеспечит уникальность ID и во времени тоже. Не надо будет узлам хранить бесконечно растущее множество ID

5. Issues: ID без экспирации должны быть недешевы, т.к. они навсегда, ключ для ID менять нельзя. PoW для публикации на AddressBook со сложностью в зависимости от expire time?

### Сценарий

1. Alice генерирует ID и пару ключей. Публикует в AddressBook пару { ID, public_Key }, такое взаимодействие:
	* из соединения с BeamNode получает список адресов AddressBook (или уже их знает)
	* соединяется с AddressBook узлом, первого удачного соединения из полученных адресов достаточно, получает nonce на PoW, делает запрос с полями { ID, public_Key, nonce, PoW }
	* узел AddressBook проверяет можно ли публиковать такой ID, проверяет PoW. Возвращает либо отказ, либо шифровку(public_Key, random_Nonce)
	* Alice расшифровывает random_Nonce, отправляет это подтверждение назад
	* узел AddressBook получает подтверждение и публикует на DHT то что нужно

2. Bob желает от Alice взаимности по безопасному каналу и каким-то образом знает ID, куда подкатывать. Для этого:
	* из соединения с BeamNode получает список адресов AddressBook (или уже их знает) и список адресов BBS, какие каналы кто из них обслуживает
	* соединяется с AddressBook узлом, получает public_Key по ID, формирует множество M1 из M каналов BBS
	* отсылает сообщение в M1, в нем может содержаться его какое-то временное ID_Bob, не обязательно опубликованное + publicKey_Bob + какие-то позывные для Alice + информация о TX конечно же
	* формирует множество M2 адресов BBS из { ID_Bob, publicKey_Bob } и цепляется к этим BBS, но не обязательно в онлайне

3. Тем временем Alice тоже знает множество каналов M1 и слушает их, не обязательно в онлайне. Но в онлайне весь диалог будет быстрее, ясен пень. При возврате из оффлайна можно запрашивать историю хотя бы из одного BBS этого множества и пытаться выловить что-то оттуда. При получении чего-то интересущего может сформировать M2 и слать туда.

### Разное

1. Можно опционально высылать сообщения в меньшее число каналов m = 1..M-1, но тогда получателю надо слушать все M каналов. Или наоборот: высылать во все M, а активно слушать только один из, в случае дисконнекта получателю подключаться к нескольким каналам и смотреть историю

2. DDoS на BBS: при большом N имеет смысл какой-то PoW на каждую BBS публикацию. При малом N более радикальное решение: каждый BBS канал является P2P сетью в которой сообщения между узлами реплицируются

3. Второе и последующие сообщения диалога могут отправляться p2p через ретранслятор или напрямую, чтоб не тратить ресурсы. Это если сторонам не нужна анонимность