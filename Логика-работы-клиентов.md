Клиент должен обрабатывать следующие события:
* Состояние блокчейна (получение и обработка заголовка блока, тела блока, запрос истории блоков и т.п.)
* Запросы другого клиента (инициирование и участие в транзакции)
* Запросы пользователя
* Ошибки (сеть, storage, etc.)

# Состояние блокчейна
Логика обработки блокчейна достаточно жёстко определена и здесь всё более-менее понятно. Общие правила:
* Имеют значение лишь полностью правильные данные (заголовки и блоки). Данные которые не проходят валидацию немедленно удаляются, и никакой роли не играют.
* Клиент всегда считает "активной" полноценную цепочку (т.е. без пропусков) с маскимальной суммарной сложностью.

### Понятие горизонта

По мере работы с блокчейном клиент должен уметь не только обрабатывать новые блоки, но и "откатываться" назад (если образовалась новая цепочка с большей сложностью). _Горизонтом_ называют кол-во блоков начиная с последнего, на которое клиент может "откатиться" назад без посторонней помощи.

Откат назад требует хранения какой-то информации (блоков и/или каких-то сгенерированных локальных данных). Если клиент хранит все данные, то он может вернуться куда угодно, в этом случае его горизонт неограничен.

Клиент может решить ограничить горизонт, чтобы со временем "подчищать" историю. В этом случае при откате ему надо будет у другого клиента получить недостающую информацию. Или, возможно, полный сброс и синхронизация заново.

### Выбор активной цепочки

Диаграмма из Грина:

![Схема из Грина](https://github.com/beam-mw/grin/blob/master/doc/chain/images/sync_on_fork.png)

Смысл в том что разделяются заголовки блоков и сами блоки. Прежде всего клиент получает заголовки, и по ним выстраивается дерево блокчейна.

Если мы говорим про кошелёк, то ему больше ничего не нужно. Он получает заголовки, выстраивает из них дерево, и в каждый момент времени знает какая ветка активна.


По заголовкам он выбирает активную ветку, но при этом он получает также заголовки которые дополняют неактивные ветки



клиенты работают с заголовками блоков, 



Исходя из этого предлагаем такую логику поведения клиента. Во-первых обозначим 2 типа клиентов: узел и кошелёк. Узел - это полнофункциональный клиент, который делает полную валидацию блокчейна, а кошелёк работает лишь с заголовками. Оба клиента следуют одной логике, но детали имплементации отдличаются.


Оба типа клиентов считают активной цепочку с маскимальной суммарной сложностью. Но по мере получения новых блоков им, возможно, приходится 

так или иначе работают с элементами блокчейна (будь то заголовки или полноценные блоки)

## Узел


разделим узел и 


   * Получен новый элемент блока
      * заголовок + PoW
      * Тело блока
* Запросы пользователя (создание и участие в транзакции)
   * запрос по поводу транзакции
   * Запрос на получение док-ва Меркла на конкретный объект
   * запрос на получение истории

* Ошибки
