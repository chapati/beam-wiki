Proof-of-work & Mining
======================

# Что такое Proof-of-Work и зачем он нужен?
**Proof-of-work** - это механизм(протокол) в децентрализованной системе, направленный на то, чтобы разрешать спорные ситуации между элементами системы.
То есть один участник должен доказать другому, что он имеет право сделать определенное действие, например, послать письмо в антиспам системе или добавить блок в **blockchain**.
## Формальное описание схемы работы PoW
Пусть **_P(I, R, S)_** - это некий предикат, который принимает входные данные решаемой задачи **_I_**, параметры сложности **R** и решение **S**. Этот предикат дает **_true_** только если решение **S** соответствует **I** и **R**

1. Сторона, которая должна доказать, что она выполнила работу(*_Prover_*) получает задание(**I**) и параметры, определяющие сложность задачи(**R**)
2. **_Prover_** находит решение задачи(**S**), такое, что **_P(I, R, S) == true_** 
3. **_Verifier_** получает **S**, удостоверяется, что **_P(I, R, S) == true_** и делает то, что хочет **_Prover_**

## Требования к алгоритмам PoW
Фактически в качестве PoW может выступать достаточно большое количество задач.
Различают алгоритмы:

* СPU-bound
* Memory-bound
* Network-bound 

Главное чтобы:

* задача должна быть асимметричной, то есть поиск решения задачи должен быть очень сложным, а проверка полученного решения должна быть тривиальной
* малое изменение входных параметров сложности, должно приводить к значительному изменению сложности поиска решения задачи
* задача не должна хорошо оптимизироваться, чтобы одни участники, решающие задачу, не имели значительного превосходства над другими
* так же аппаратное решение задачи не должно приводить к значительному преимуществу, например ввиду стоимости площади кристалла отводимому под память
* задача должна иметь ограничения по распараллеливанию, то есть выигрыша от параллельного выполнения должны нивелироваться издержками на передачу данных.  

## Equihash
**_Equihash_** - это _memory-bound_ алгоритм PoW, по утверждениям авторов неплохо удовлетворяет вышеуказанным требованиям [white paper](http://orbilu.uni.lu/bitstream/10993/22277/2/946.pdf)

Приблизительное описание того, что происхоит.

Суть в том, что решается [_обобщенная задача совпадения дней рождения_](https://ru.wikipedia.org/wiki/Парадокс_дней_рождения), плюс судя по всему авторы добавили сюда дополнительный шаг для контроля сложности а-ля bitcoin.

Задача следующая: есть список _n_- битных строк **{X<sub>_i_</sub>}**, требуется найти в этом списке подмножество различных между собой строк таких, что
    **{X<sub>_i_<sub>_1_</sub></sub>}** xor **{X<sub>_i_<sub>_2_</sub></sub>}** xor .. xor **{X<sub>_i_<sub>_2_<sup>_k_</sup></sub></sub>}** == 0

Список таких строк можно генерировать генератором хэшей **H**, который работает в режиме счётчика.
    **H(_i_<sub>_1_</sub>)** xor **H(_i_<sub>_2_</sub>)** xor .. xor **H(_i_<sub>_2_<sup>_k_</sup></sub>)** == 0

**_n_** и **_k_** - это входные параметны для поиска решения
**_d_** - сложность

**Equihash** предлагает формировать данные для генерации хэшей путем конкатенации следующих полей:
**I** - входные данные для PoW (в **Zcash** это хэш блока, который берется от хэша предыдущего блока, корня Меркля, времени и пр.)
**V** - _nonce_ это значени получается в процессе поиска решения, простым перебором (в оригинальной работе это 32-битное число инкрементируемое в цикле начиная с 1, в Zcash 256-битное)
**_x_<sub>_i_</sub>** - части решения

Решение проблемы выглядит как **V** и список **_x_<sub>_i_</sub>**
Причём решение должно удовлетворять условиям задачи, плюс разработчики добавили критерий хэша как для _bitcoin_ и немного своих соображений (|| - конкатенация)
* **H(I || V || _x_<sub>_1_</sub>)** xor **H(I || V || _x_<sub>_2_</sub>)** xor .. xor **H(I || V || _x_<sub>_2_<sup>_k_</sup></sub>)**  == 0 // условии задачи о днях рождения 
* **H(I || V || _x_<sub>_1_</sub> || _x_<sub>_2_</sub> || ... || _x_<sub>_2_<sup>_k_</sup></sub>**) имеет **_d_** нулей вначале

есть еще критерий, но его еще не осознал.

**Prover**
1. Принимает **I**, **_n_**, **_k_** и **_d_**
2. Далее цикл поиска решения. Последовательно перебираются значения **V** (nonce)
3. Для текущего **V** генерируются хэши на основе  **I**, **_n_**, **_k_**(**_x_<sub>_i_</sub>** формируются на этом этапе), чем собственно и занимает память
4. Ищет во множестве сгенерированных хэшей, те, что удовлетворяют условиям задачи
5. Если решение не найдено, **V** инкрементируется и начинается новая итерация поиска.

**Verifier**
1. Знает **H**, **I**, **_n_**, **_k_** и **_d_**, получает **V** и {**_x_<sub>_i_</sub>}
2. Вычисляет **H(I || V || _x_<sub>_i_</sub>)** и проверяет условия.

Стоит сказать, решение зависимости от параметров занимает от десятков байт до килобайт. Zcach это решение встраивает в блок.

Также авторы рекомендуют для криптовалют параметры _n_ и _k_ (100/110/120,4), (108/114/120/126,5).
В Zcash принято _n_ = 200, _k_ = 9.

Также в текущих реализациях в качестве хэш-функции принят **black2b**, но авторы пишут, что можно выбрать и другой


### Реализации

* [реализация от авторов](https://github.com/khovratovich/equihash)
* [две реализации в Zcash](https://github.com/zcash/zcash/tree/master/src/crypto)
* [используется в Zcash](https://github.com/tromp/equihash)
* [Zcash 2](https://github.com/zcash/zcash/tree/master/src/pow/tromp)
* [без исходников но CUDA](https://bitcointalk.org/index.php?topic=2021765.0)
* [еще](https://www.bminer.me/examples/)
* [хардкор](https://github.com/xenoncat/equihash-xenon)


# Майнинг
**Майнинг** - это процесс добычи криптовалюты. Технически заключается в формировании нового _блока_ данных из имеющихся _транзакций_ и решении задачи **PoW** основе текущего состояния **blockchain**.

# Структура майнера grin

### как выглядит одна итерация цикла майнера в Grin с Cuckoo Cycle PoW:
- создает новый блок в голове блокчена со следующим параметрами:
	- сложность, пересчитывается каждый раз после создания нового блока опираясь на текущую мощность сети (_учитывается среднее медианное значение интервалов создания последних 23 блоков в цепочке_)
	- выбирает транзакции из пула для валидации
	- добавляет coinbase транзакцию с вознаграждением за решенную задачу PoW
	- время создания (_timestamp_)
	- генерирует рандомный **nonce** (одноразовый код, выбранный случайным образом)
	- хеш корня дерева **Меркла** добавленых транзакций **UTXO** + комиссий
	- запускается вложенный цикл, который работает определенное время (_на данный момент 2 секунды_):
		- хеширует заголовок нового блока
		- иницализируется генератор графа для **Cuckoo Cycle**, если не был создан до этого, который принимает параметры:
			- хеш заголовка потенциального блока, который будет использоваться как ключ для **SIPHASH** функции, которая, в свою очередь, будет генерировать пары для позиций каждого элемента в наборе nounces `0..N` в графе
			- размер графа
			- **easiness value**, представляет собой вероятность появления решения в графе
		- алгоритм **Cuckoo Cycle** пытается найти решение используя предоставленный граф
		- если решение найдено, сравнивается **Blake2b** хеш от решения и сравнивает его с текущей сложностью
		- если сложность **Blake2b** хеша больше текущей, сложность добавляется в блок, блок добавлятся в блокчейн и отправляется другим узлам для проверки, и начинается работа со следующим блоком
		- если сложность **Blake2b** хеша меньше текущей сложности, решение (_Proof of Work_) отклоняется и цикл продолжает свою работу
		- если решение не найдено, значение nounce в заголовке инкрементируется на 1, и обновляется время создания заголовка (_timestamp_)
		- если цикл прекратил свою работу (_2сек_) и решение не было найдено, мы возвращаемся в главный цикл, и начинаем все сначала, новый блок, добавляем транзакции из пула...

### Верификация
## Интеграция Equihash в grin
