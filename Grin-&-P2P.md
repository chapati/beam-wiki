## В общих чертах что происходит в модуле p2p от grin:

* Соединение между 2мя узлами по TCP, один из которых сервер p2p, 2й клиент. Происходит handshake.
* В планах TLS, но сомннительно, зачем он нужен там, это ведь нужны сертификаты, которых у данных узлов скорее всего не будет. Просто сделать обмен ключами и шифровать трафик? - тоже непонятно, нужно ли это, т.к. все секреты и так зашифрованы, а остальное может и должно быть открыто.
* В планах dandelion, но пока его нет в реализации
* На узле могут явно задаваться белый и черный списки адресов, allow/deny, по умолчанию все разрешены
* В процессе какой-то адрес моет быть забанен (автоматически, если он шлет поврежденный трафик, либо явно). Адрес может быть явно разбанен
* Далее происходит обмен сообщениями через TCP. Их немного видов, одни требуют ответа, другие нет (broadcast). Формат ниже.

## Особенности реализации в grin:
* Главная структура, через которую происходит синхронизация c остальной системой, это Peers (./src/peers.rs). В ней имеется ChainAdapter: ловит сообщения от подключенных узлов и апдейтит внутреннее состояние, PeerStore: персистентное хранилище (завязано на общую БД, сохраняет информацию об узлах, см. ./src/store.rs), peers: hashmap в памяти на узлы, с которыми идет взаимодействие, см. ./src/peer.rs
* Сервер создает отдельный поток "p2p-monitor", который раз в 10 секунд освежает total_difficulty и total_height блокчейна и побуждает все соединенные узлы отправить ping с этими параметрами (см. ниже Протокол).
* Listen у сервера в бесконечном цикле (see Server::listen(), ./src/serv.rs). Каждую 1 мс ловит новое соединение, проверяет не заблокирован ли данный узел, если ok, стартует handshake и добавляет новое соединение во внутренние структуры
* Клиентское соединение происходит через Peer::connect(), (peer.rs), инициируется структурой Server, так вот. Handshake подробнее ниже описано.
* Thread per connection (ужас, и кругом RWLock-и, понятно, что надо по-другому это делать, так что детали межпоточных взаимодействий не хочу подробно описывать, но они есть).
* Смешались в кучу кони/люди, см. напр. ./src/adapters.rs (и везде, где impl для ***Adapter присутствует). Реализация какой-то отдельно взятой из общей логики идеи может быть не только в разных файлах, но и в модулях. Мы так не будем делать.

## Инициализация p2p сервера (т.е. аргументы Server::new())
* db_root: String - и блокчейн, и p2p persistence (PeerStore), управляются общей БД
* capab: Capabilities - это флаги, что из себя представляет узел: FULL_HIST (содержит всю историю блокчейна), TXHASHSET_HIST (содержит заголовки и недавнюю историю), PEER_LIST (может давать список доступных узлов)
* сonfig: P2PConfig - конфигурация узла, см. ниже
* adapter: Arc< ChainAdapter > - бридж с остальной системой, ловит сообщения из сети, см. ниже
* genesis: Hash - hash genesis блока
* stop: Arc< AtomicBool > - атомный флажок, проверяется тредами, когда выходить

### Структура P2PConfig (./src/types.rs): Конфигурация узла
#### Адрес, куда принимаем входящие
* host: ip address of listening interface (may be specified, but typically is 0.0.0.0 for default external or 127.0.0.1 for local, but ipv6 is also supported there)
* port: port to listen to, u16
#### Политика explicit allow/deny. Эти списки могут быть пустыми (по умолчанию)
* peers_allow: список разрешенных адресов соединений
* peers_deny: список запрещенных адресов соединений

### ChainAdapter: бридж с остальной системой
#### Методы (p2p запрашивает у БД информацию для отправки в сеть):
* total_difficulty - возвращает актуальную difficulty 
* total_height - возвращает актуальную для данного узла высоту от genesis
* locate_headers - ищет по заданному списку хэшей последний общий между этим узлом и другим блок и возвращает список хедеров для отправки в узел, не более MAX_BLOCK_HEADERS=512
* get_block - ищет блок по хэшу для отправки в узел по его запросу
* txhashset_read - извлекает из TxHashSet (см. ../chain/{chain,txhashset}.rs) по заданному хэшу транзакции информацию, пригодную для отправки в узел и нужную последнему для синхронизации в состояние, соответствующее этому хэшу. Возвращается структура (индекс выходов, индекс кернелов, сжатый в bzip2 кусок TxHashSet)
* txhashset_write - синхронизирует TxHashSet этого узла в соответствии с принятой структурой (см. txhashset_read)

#### Коллбэки (новая информация приходит из сети и обновляет состояние БД):
* transaction_received - пришла транзакция
* block_received - пришел Block (см. ../core/block.rs) от какого-то узла
* compact_block_received - пришел компактный блок CompactBlock (см. ../core/block.rs)
* header_received - пришел BlockHeader от какого-то узла (см. ../core/block.rs)
* headers_received - пришел список BlockHeader от какого-то узла

### NetAdapter: расширяет ChainAdapter (сетевые операции, не требующие взаимодействия с БД)
#### Метод:
* find_peer_addrs - ищет список валидных адресов для отправки в сеть по запросу
#### Коллбэки:
* peer_addrs_received - от какого-то узла пришел список валидных адресов
* peer_difficulty - пришла информация о total_difficulty+total_height от какого-то узла

## Handshake
* см. ./src/handshake.rs
* успешный хендшейк возможен при следующих условиях:
	1) совпадают genesis хэши, т.е. 2 узла принадлежат одной сети
	2) совпадают PROTOCOL_VERSION
	3) узел, с которым соединились, не в списке denied
	4) узел не сам с собой соединился (по nonce это проверяется)
* клиентская сторона отправляет сообщение Hand (Handshake::initiate), серверная сторона отвечает сообщением Shake (Handshake::accept)

## Протокол
#### У каждого сообщения есть заголовок из 11 байт:
* MAGIC: 2 байта 1ec5
* type: тип сообщения, 1 байт
* size: длина сообщения, максимум 20_000_000, зачем-то 8 байт
### Сообщения:
#### Error:
Отправляет код + сообщение возникшей ошибки, после чего связь прекращается.

#### Hand:
Хендшейк со стороны клиента. В ответ ожидает Shake. Внутри следующее:
* version: u32 - версия протокола
* capabilities - битовая маска о том, что представляет собой данный узел (имеет ли он полную историю и т.п.)
* nonce: u64 - случайное число, генерируемое при каждом соединении, нужно против loopback соединений
* genesis: Hash - hash genesis блока
* total_difficulty - накопленная difficulty, по ней узлы определяют с кем бы им синхронизироваться, если нужно
* sender_addr: SockAddr - адрес исходящий
* receiver_addr: SockAddr - адрес входящий
* user_agent: String - подражание http, для будущей статистики насколько баговистый тот или иной user agent (?)

#### Shake:
Ответ серверной стороны на Hand. Внутри:
* version: u32 - версия протокола
* capabilities - битовая маска о том, что представляет собой данный узел (имеет ли он полную историю и т.п.)
* nonce: u64 - случайное число, генерируемое при каждом соединении, нужно против loopback соединений
* genesis: Hash - hash genesis блока
* total_difficulty - накопленная узлом difficulty
* user_agent: String

#### Ping:
Используется как heartbeat. Передает узлу свое текущее состояние полями
* total_difficulty - накопленная узлом difficulty
* height - расстояние последнего блока от genesis

Принимающая сторона вызывает adapter.peer_difficulty(), записывает состояние отправителя и отвечает сообщением Pong

#### Pong:
Ответ на Ping, содержит те же поля, что и Ping и точно так же апдейтит состояние контрагента.

#### GetPeerAddrs:
Запрашивает у узла список известных ему peer адресов, обладающих заданными возможностями. Передает:
* capabilities: битовая маска

#### PeerAddrs:
Ответ на GetPeerAddrs. Приходит список адресов.

#### GetHeaders:
Запрос на заголовки с целью синхронизации. Отправляется:
* список хэшей

Принимающая сторона формирует список хедеров, найдя в запросе точку, до которой она и отправитель синхронный
(adapter.locate_headers()).

#### Header:
Приходит заголовок блока (см структуру BlockHeader). Распространяется броадкастом, когда полявляется новый блок. Если у принимающей стороны еще нет этого блока, она может ео запросить через GetBlock.

Принимающая сторона вызывает adapter.header_received()

#### Headers:
Ответ на GetHeaders. Приходит:
* список BlockHeader.

У принимающей стороны происходит синхронизация через adapter.headers_received().

#### GetBlock:
Запрашивает полный блок у другого узла по хэшу. Отправляется:
* хэш блока.

Принимающая сторона по хэшу блока находит блок (adapter.get_block()), отвечает сообщением Block

#### Block:
Приходит блок в ответ на запрос GetBlock:
* полный блок: заголовок,inputs,outputs,kernels.

Вызывает коллбэк adapter.block_received()

#### GetCompactBlock:
То же, что и GetBlock, только отвечает компактным блоком (а если блок пустой, то полным)

#### CompactBlock:
Приходит:
* компактный блок

Принимающая сторона вызывает adapter.compact_block_received()

#### Transaction:
Принимает core::Transaction и обновляет состояние системы (коллбэк adapter.transaction_received()). Внутри:
* offset - это kernel offset для транзакции, big number, см. splitting keys
* длины inputs, outputs, kernels
* сериализованные списки inputs,outputs,kernels в отсортированном виде

#### TxHashSetRequest:
Запрос на hashset транзакций для блока. Отправляются:
* hash: Hash - хэш нужного блока
* height: u64 - высота этого блока

Принимающая сторона отвечает сообщением TxHashSetArchive.

#### TxHashSetArchive:
Ответ на TxHashSetRequest. Содержит:
* hash: Hash - хэш нужного блока
* height: u64 - высота этого блока
* rewind_to_output: u64 - индекс в дереве outputs, куда откатываться
* rewind_to_kernel: u64 - индекс в дереве kernels, куда откатываться
* attachment: сам хэшсет в формате bzip2, записывается принимающей стороной в файл
