# Transaction creation protocol

Creating transactions in Beam (as with other MimbleWimble implementations) is interactive. In order to create a new Beam transaction, the sending and receiving wallets communicate with each other. The wallets exchange parameters which produce the transaction. As a result, the protocol between the wallets is extendable.

## What is a transaction in Beam?
Any Beam transaction contains the following parameters:

* A Set of input UTXOs (Inputs), which have to already be present in the blockchain.
* A Set of newly created UTXOs (Outputs) and rangeproofs for each output
* The Explicit excess (offset)
* The transaction kernel

The transaction kernel requires the following parameters:
* Blinded excess
* Transaction fee
* Minimum height
* Maximum height
* Signature. This is a Schnorr’s multi-signature which signs all the values listed above

The minimum and maximum height values set the time in which the transaction is valid. Nodes will reject a transaction if its height is below the minimum height and greater than the maximum height

### A simple transaction flow.
In the following example, a _Sender_ makes a payment to a _Receiver_.

* _Sender_ and _Receiver_ agree on the _amount_ and _fee_.
* The _Sender_ selects input UTXO which allow paying _amount + fee_.
  * If the sum of inputs is greater than _amount + fee_, _Sender_ also creates output UTXO for the change. 
  * The _Sender_ creates overall blinding excess value `blindingExcess_S` and `offset_S`
* The _Receiver_ creates output for a given amount and calculates blinding excess `blindingExcess_R` and `offset_R`
* Both parties generate nonces `nonce_S` and `nonce_R` respectively.
* Both parties send each other public forms of excesses:
  * `publicNonce_S = nonce_S*G` and `publicNonce_R = nonce_R*G` – public nonces
  * `publicExcess_S = blindingExcess_S*G` and `publicExcess_R = blindingExcess_R*G` – public blinding excessed
* Both parties compute total blinding excess and total public nonce:
  * total blinding excess: `X = publicExcess_S + publicExcess_R`
  * total public nonce: `K = publicNonce_S + publicNonce_R`
* Both parties compute a Schnorr’s signature challenge:
  * `e = H(K|M)`, where `M` is a signed message, it calculates from kernel and it includes `X`, `fee`, `min height`, and `max height`
* Both parties compute and send  to each other partial signatures:
  * `S`: `partialSignature_S = publicNonce_S + e*publicExcess_S`
  * `R`: `partialSignature_R = publicNonce_R + e*publicExcess_R`
* Final signature is computed: `signature = partialSignature_S + partialSignature_R`

[[/images/SimpleTransactionFlow.png]]

## Wallet-To-Wallet protocol
The protocol itself consists of only one message. It should allow to implement all the required scenarios and transaction types. Also, this message can be encapsulated and passed to other part by using different means: as a direct message sent over a p2p connection or an indirect message sent using secure bulletin board system (SBBS) and others.

## SetTxParameter
Transfers a pack of transaction’s parameters from one wallet to another. This message may initiate a new transaction. 

-	`WalletID m_From` – the address which wallet wants to use for responses, used when sending messages over **SBBS**. `WalletID` is packed 8 bytes of BBS channel and 32 bytes of wallet’s public key.
-	`TxID m_TxID` – unique 16-byte transaction identifier. Generated by transaction initiator.
-	`TxType m_Type` – transaction’s type like `Simple, AtomicSwap` etc. This field is used to create new transaction object, when this message is the first in a line, or for verification purposes.
-	`std::vector<std::pair<TxParameterID, ByteBuffer>> m_Parameters` – vector of pairs of transaction’s parameters. Each parameter is a pair of ID from range [0...255], and value represented as a raw bytes buffer. ID values are separated in two parts: private and public (ids below `PrivateFirstParam == 128` are private). Public parameters come from outside and they are not allowed to be overridden. Private parameters do not have limitations.

## Example: Simple transaction

Simple transaction is a payment from Wallet A to Wallet B, with a change UTXO and fee. 

### Wallet A sends an invitation.

```javascript
SetTxParameter
{
    m_From: XXXXXX // ID of the wallet to receive the response.
    m_TxID: 651798 // newly generated random identifier.
    m_Type: TxType::Simple,
    [
        {TxParameterID::Amount, amount},
        {TxParameterID::Fee, fee},
        {TxParameterID::MinHeight, minHeight}, 
        {TxParameterID::MaxHeight, maxHeight}, 
        {TxParameterID::IsSender, false}, // flag to distinguish the sender from the receiver.
        {TxParameterID::PeerInputs, inputs}, 
        {TxParameterID::PeerOutputs, outputs},
        {TxParameterID::PeerPublicExcess, publicExcess}, 
        {TxParameterID::PeerPublicNonce, publicNonce},
        {TxParameterID::PeerOffset, offset}
    ]
}
```
* `minHeight `- if height of the blockchain is less than the specified value, the transaction will not be taken into account.
* `maxHeight` - if height of the blockchain is greater than the specified then node will reject created transaction.
* `inputs` - vector of inputs (commitments) chosen by sender.
* `outputs` - vector of change outputs, created by sender.
* `publicExcess` - public form of sender’s excess calculated from blinding factors of inputs and change output.
* `publicNonce` - sender generates secret nonce, this is its public value.
* `offset` -  offset value, randomly taken part of change output blinding factor.



### Wallet B confirms invitation.
Wallet B creates an output for the received amount and generates a nonce to sign transaction.
```javascript
SetTxParameter
{
    m_From: YYYYYY  // the ID of the wallet to receive response.
    m_TxID: 651798, // the same ID as sender.
    m_Type: TxType::Simple,

    [
        {TxParameterID::PeerPublicExcess, peerPublicExcess},
        {TxParameterID::PeerSignature, receiversPartialSignature},
        {TxParameterID::PeerPublicNonce, publicNonce}
    ]
}
```
* `peerPublicExcess` - receiver’s public excess, calculated from the output’s blinding factors.
* `receiversPartialSignature` - receiver’s part of Schnorr multi signature.
* `publicNonce` - public form of nonce for signature.


### Wallet A confirms the transaction. 
If the receiver’s signature is valid, it calculates its part of signature
```javascript
SetTxParameter 
{
    m_From: XXXXXX // chosen wallet’s ID to receive response.
    m_TxID: 651798, 
    m_Type: TxType::Simple,
    [
        {TxParameterID::PeerSignature, sendersPartialSignature}
    ]
}
```
`sendersPartialSignature` - the calculated signature of the sender

Now wallet B has all data required to create transaction and send it to a node.

### Cancellation or error

If any of the participants wishes to interrupt the process for any reason, it sends the following message:
```javascript
SetTxParameter 
{
    m_From: ZZZZZZ // chosen wallet’s ID to receive response
    m_TxID: 651798, 
    m_Type: TxType::Simple,
    [
        {TxParameterID::FailureReason, reason}
    ]
}
```
`reason` - 32 bit code of failure reason

