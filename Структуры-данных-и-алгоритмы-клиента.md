Здесь мы рассмотрим варианты того как полноценный клиент может имплементировать логику блокчейна.
Эфективный дизайн зависит от того какую именно функциональность поддерживает клиент, и какие возможности мы хотим предоставить пользователям системы. Разделим функциональность на следующее:

1. Валидация блоков
1. Майнинг
1. Генерация скомпрессированной истории (поддержка старта новых клиентов)
1. Путь Меркла на UTXO в блоке в котором он был создан
1. Путь Меркла на UTXO в произвольном блоке
1. Путь Меркла на ядро транзакции в блоке в котором оно был создано
1. Путь Меркла на ядро транзакции в произвольном блоке

Напомним что путь Меркла на ядро транзакции - новая функциональность, которая (АФАИК) не предусмотрена в грине, но даёт определённые преимущества.

Состояние системы описывается следующими объектами
* Непотраченные UTXOs, т.е. их *идентификатор* и сигнатура.
   * Идентификатором является Pedersen commitment и, возможно, дополнительные параметры:
      * Номер блока в котором он появился (опционально), чтобы знать его зрелость.
      * флаги: является ли он обычным или coinbase, является ли он открытым
   * Сигнатура представляет из себя rangeproof (в обычном варианте) или подпись Шнорра (если он открытый)
* Ядра транзакций
   * Содержит сообщение и сигнатуру

* UTXO
   * Идентификатор UTXO: точка на кривой (257 бит), номер блока (64 бита?), флаги. Всего 41 байт.
   * Сигнатура. в случае с закрытым UTXO компактный rangeproof (bulletproof) занимает 700 байт.
   * На 2016-07-19 в биткоине существовало около 5 млн. UTXOs
* Ядра транзакций.
   * Сообщение может содержать произвольные поля. Как правило содержит *fee* и опционально (?) номер блока в котром считается валидным.
   * Подписывается сигнатурой Шнорра.
   * Следует ограничить максимальный размер сообщения, если клиенту нужно внедрить много информации, то он может её хранить отдельно, а в сообщении закодировать хэш.
   * Примерная оценка размера: 112-160 байт (2 точки на кривой, скаляр и пр.)
   * На 2016-07-19 в биткоине существовало около 150 млн. транзакций.

Заметим что UTXOs появляются и исчезают в произвольном порядке, а ядра тразакций появляются и никуда не исчезают. Размеры и порядки величин:

# Минималистский дизайн

Предположим что клиент заинтересован только в (1) и (2). Как мы уже говорили, валидация блока, помимо того что есть в блоке, подразумевает знание текущих UTXOs. При этом локально хранить ялра транзакций и сигнатуры UTXOs необязательно. Но в любом случае клиент должен уметь проверять и пересчитывать описание состояние системы (хэш корня Меркла).

## Ядра транзакций

Хранить не надо, но надо вносить в дерево Меркла.

Для удобства договоримся что состояние системы кодируется не одним, а двумя деревьями Меркла: одно для UTXOs а второе для ядер, а полное описание состояния системы - это хэш из двух соответствующих хэшей. Иначе говоря, общее дерево Меркла делится на 2 ветки: одна для UTXOs, вторая для ядер.

Это удобно по той причине что, как мы сказали, ядра могут только добавляться. Поэтому зная порядковый номер интересующего нас ядра и общее кол-во ядер можно просто вычислить путь к соответствующему ядру.

Договоримся что по мере добавления элементов дерево растёт по принципу MMR. на простом языке это значит что дерево заполняется по порядку слева направо, всякий раз когда оно заполняется полностью у него появляется новый корень и открывается новая ветка справа.

Для того чтобы иметь возможность добавлять новые элементы в такое дерево необязательно полностью знать его структуру. Достаточно лишь знать путь к последнему добавленному элементу. Таким образом состояние ядер транзакций кодируется компактной структурой размера O(log(N))

## UTXOs

Они должны храниться в индексированном виде, позволяющий быстрый (логарифмический) поиск, удаление и добавление. Индекс (т.е. ключ для поиска) включает в себя следующее:
1. Pedersen commitment
1. Флаги
1. Номер блока

Такой индекс позволяет найти UTXO по *неполному* описанию. Например, участник может указать лишь commitment, и если таких несколько, то клиент может выбрать подходящий сам исходя из детерминистской логики.

**Важно:** Структура данных должна подразумевать <u>стабильную сортировку</u>. Т.е. если существуют 2 UTXOs с идентичным описание (а мы хотим такое поддежать), то поиск/итерация должна их выдать в одном порядке на всех клиентах, это важно в контексте описания системы при помощи дерева Меркла (как мы увижим позже).

Для каждого UTXO надо хранить следующие параметры:
* Его хэш в дереве Меркла
   * Как вариант можно хэш не хранить а пересчитывать когда надо, но в этом случае надо будет также хранить сигнатуру, а она гораздо больше.
* Ссылку на узел (parent) в дереве Меркла

Помимо этого надо хранить дерево Меркла UTXOs, причём ссылки должны быть двусторонними. Каждый узел должен хранить:
* Хэш
* Ссылки на 2 дочерних узла
* Ссылка на родительский узел
* Суммарное кол-во *дырок* закодированное в дочерних узлах (т.е. сколько там можно поместить новых UTXOs)
* Флаг *dirty*

### Как работает добавление и удаление UTXOs

Договоримся что дерево Меркла UTXOs также организовано по принципу MMR. Но, в отличие от дерева ядер, у нас элементы могут удаляться. Поэтому мы отслеживаем *дырки* в дереве, и каждый новый элемент мы сперва пытаемся поместить в самую левую дырку. Таким образом мы экономим высоту дерева. Но при этом если дерево выросло, то мы не пытаемся его впоследствие уменьшить (ротации и т.п.). Статистически мы предполагаем что кол-во UTXOs будет расти.

Модификация включает 2 стадии:
1. Добавление/удаление элементов
1. Пересчёт нужных хэшей и индикаторов заполненности

Мы создаём список *грязных* узлов. Во время (1) мы добавляем/удаляем нужные элементы, и при этом помечаем их прямых родителей как *грязных*: Если у них не был выставлен флаг, то мы его выставляем, и вносим их в список (таким образом чтобы никакой узел не оказался в списке дважды).

Заметим что все оказавшиеся в списке узлы имеют одну высоты (на 1 выше чем листья).

После этого мы переходим к (2). Для каждого узла в *грязном* списке пересчитываем его хэш и кол-во дырок, убираем его *грязный* флаг, и вместе с этим помечаем *грязным* его родителя (если он существует), т.е. по такой же логике если у него не стоял *грязный флаг*, то выставляем его и вносим в список. Процесс продолжнается пока список не станет пустым.

Такой алгоритм позволяет свести к минимуму пересчёты хэшей когда происходят много изменений в дереве.

### Индексация UTXOs

Нам нужно что-то вроде `std::multimap`. Но с учётом того что данных может быть слишком много и их нельзя хранить в памяти. Т.е. нужен аналог, но вместо памяти это должно быть на persistent storage (в файле).

Один из вариантов: можно взять готовый DB (sqlite & friends), но нужно убедиться что в нём выполняется *stable sort*, т.е. данные с одним ключом находятся в порядке добавления.

### Альтернативный вариант для UTXOS и дерева Меркла

Можно совместить дерево Меркла и дерево индексации UTXOs (это вполне уднобный вариант если мы это имплементируем сами, а не используем готовый DB). Но надо учесть следующее:

* Это уже будет не дерево Меркла, т.к. у нас данные будут храниться во всех узлах (а не только на нижем уровне). Таким образом путь в этом дереве будет иметь другое описание, фактически в каждом узле будут 3 хэша: левый/правый сын и текущий элемент.
* При модификации (удалении/добавлении элементов) будет больше пересчётов хэшей. Это будет всё ещё O(log(N)), но всё-таки больше (ввиду больших внутренних манипуляций дерева, ротаций и т.д.)
* Суммарный размер данных уменьшается.

## Работа с блокчейном, смена ветки консенсуса

Каждый новый блок проверяется, и если всё ок, то клиент *съедает* блок, т.е. модифицирует своё состояние в соответствии с блоком. Но если получается так что обработанный блок не входит в текущий блокчейн, то надо *откатиться* назад.

Мы говорили что обработка блока *обратима*, т.е. его можно интерпретировать в обратном порядке, чтобы восстановиться в предыдущее состояние. Однако это потребует сохранение некоторых дополнительных данных.

### Дерево ядер транзакций
Нам в любой момент времени надо знать путь последнего добавленного элемента, и общее кол-во ядер. Поэтому в самом простом варианте чтобы откатиться назад нам надо сохранить путь последнего элемента до обработки нового блока. Кол-во ядер на тот момент сохранять необязательно, т.к. мы знаем сколько элементов добавляет каждый блок.

### UTXOs

Для отката назад мы можем легко удалить все те UTXOs что были добавлены последним блоком. Однако для восстановления тех которые он "съел" нам надо знать следующее:
* Бывший путь каждого такого UTXO в дереве Меркла
* Его полный идентификатор (на случай если в блоке идентификатор был неполным. Например, не включал в себя номер блока)
* Его хэш с учётом сигнатуры (которую, как мы сказали, мы предпочитаем не хранить).

Эти данные в совокупности с текущим состояним позволяют полностью восстановить текущее состояние. Таким образом, в процессе обработки блоков, должна создаваться цепочка данных для отката (rollback data) до нужной глубины.

## Требования по стабильности

Надо уметь работать с большим набором данных, нельзя предполагать что все данные можно одновременно хранить в памяти. Фактически надо уметь работать с сохранёнными данными в файле так как будет это RAM, можно для этого использовать file mapping.

Что касается устойчивости к сбоям (крэш всей системы, перебои с электричеством), то здесь требования могут быть мягче чем у DB, т.к. данные можно восстановить.

## Что именно такой клиент умеет

Поддерживаются следующие функции:

* Валидация блоков
* Майнинг
* Путь Меркла на UTXO в текущем блоке.

# Усложняем клиент, расширяем функциональность

### Ядра транзакций

Наш следующий шаг: сохранение ядер транзакций. Это легко имплементировать, т.к. ядра никогда не удаляются, и хранятся в дереве Меркла в порядке поступления. При обработке блока нам надо сохранять ядра транзакций в том виде в котором они появились в оригинальном блоке, плюс для каждого из них - путь Меркла для этого блока. 

Т.е. по сути мы сохраняем блокчейн (массив файлов) из ядер тразакций в соответствии с их блоком, где для каждого мы указываем путь Меркла. Это позволяет нам поддержать следующее:

* Путь Меркла на ядро транзакции в блоке в котором оно был создано

### Сохранение полного состояния системы

Нам для этого не хватает лишь сигнатур UTXOs. Но, как мы знаем, они имеют большой размер, и просто добавление их в структуру данных приведёт к её увеличению на порядок. Точнее с 41 байт до 741, с учётом дополнительных данных примерно 100 -> 800. Соответственно для хранения 5 млн. текущих UTXOs вместо 50Мб потребуется 4Гб.

Таким же образом раздуется и rollback data.

Для экономии I/O возможно целесообразно отделить сигнатуры от остальных данных, например хранить в другом файле и ссылаться на них.

Это позволяет нам поддержать следующее:
* Генерация скомпрессированной истории (поддержка старта новых клиентов)

## Остальные возможности

Мы пока что не имплементировали следующее:

1. Путь Меркла на UTXO в блоке в котором он был создан
1. Путь Меркла на ядро транзакции в произвольном (точнее - текущем) блоке.

Поддержка (1) ИМХО не так уж важна, но поддержать можно. Для этого во время обработки блока надо создавать файл в котором все пути Меркла к новым UTXOs будут заданы в явном виде (по аналогии с тем как это делается для ядер транзакций).

Что касается (2), то это выглядет сложно, и, вроде бы, тоже не особо важно. С точки зрения SPV клиента если ему доказали что ядро находится в одном из блоков, то, очевидно, ядро остаётся в системе по определению.

# Надо ли вообще хранить блоки?

Клиент хранит как минимум список последних блоков и rollback data к ним на случай если надо будет откатиться назад. Сверх этого по большому счёту хранить данные необязательно.
